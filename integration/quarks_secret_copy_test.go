package integration_test

import (
	"bytes"
	"fmt"
	"reflect"
	"time"

	. "github.com/onsi/ginkgo"
	. "github.com/onsi/gomega"

	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	qsv1a1 "code.cloudfoundry.org/quarks-secret/pkg/kube/apis/quarkssecret/v1alpha1"
	"code.cloudfoundry.org/quarks-utils/testing/machine"
)

var _ = Describe("QuarksCopies", func() {
	var (
		qsec          qsv1a1.QuarksSecret
		tearDowns     []machine.TearDownFunc
		copyNamespace string
	)
	const (
		qsecName     = "test.qsec"
		sourceSecret = "generated-secret"
		targetSecret = "generated-secret-copy"
	)

	checkStatus := func() {
		Eventually(func() bool {
			qsec, err := env.GetQuarksSecret(env.Namespace, qsecName)
			Expect(err).NotTo(HaveOccurred())
			if qsec.Status.Generated != nil {
				return *qsec.Status.Generated
			}
			return false
		}, 10*time.Second).Should(Equal(true))
	}

	checkCopyStatus := func() {
		Eventually(func() bool {
			qsec, err := env.GetQuarksSecret(env.Namespace, qsecName)
			Expect(err).NotTo(HaveOccurred())
			if qsec.Status.Copied != nil {
				return *qsec.Status.Copied
			}
			return false
		}, 10*time.Second).Should(Equal(true))
	}

	createQuarksSecretWithCopies := func(copyNamespace string) {
		qsec = env.DefaultQuarksSecretWithCopy(qsecName, copyNamespace)
		_, tearDown, err := env.CreateQuarksSecret(env.Namespace, qsec)
		Expect(err).NotTo(HaveOccurred())
		tearDowns = append(tearDowns, tearDown)
	}
	BeforeEach(func() {
		copyNamespace = fmt.Sprintf("%s-%s", env.Namespace, "copy")
		By("Creating copy namespace", func() {
			_, err := env.CreateNamespace(copyNamespace)
			Expect(err).NotTo(HaveOccurred())
		})
	})

	AfterEach(func() {
		err := env.DeleteNamespace(copyNamespace)
		Expect(err).NotTo(HaveOccurred())

		Expect(env.TearDownAll(tearDowns)).To(Succeed())
	})

	Context("the secret is generated by operator and qsec has copies spec", func() {
		BeforeEach(func() {
			By("Creating quarkssecret with copies")
			createQuarksSecretWithCopies(copyNamespace)
		})

		It("should not copy the generated secret to the copy namespace if no qsec or secret is found", func() {
			By("Checking the quarkssecret status")
			checkStatus()

			By("Checking if the copy secret is empty")
			secret, err := env.GetSecret(copyNamespace, targetSecret)
			Expect(err).To(HaveOccurred())
			Expect(secret).To(BeNil())
		})
	})

	Context("the secret is generated by operator for qsec copies", func() {
		BeforeEach(func() {
			quarksCopySecret := &qsv1a1.QuarksSecret{
				ObjectMeta: metav1.ObjectMeta{
					Name:      qsecName,
					Namespace: copyNamespace,
					Annotations: map[string]string{
						"quarks.cloudfoundry.org/secret-copy-of": env.Namespace + "/" + qsecName,
					},
				},
				Spec: qsv1a1.QuarksSecretSpec{
					Type:       "copy",
					SecretName: targetSecret,
				},
			}

			By("Creating copy quarks secret in copy namespace")
			_, _, err := env.CreateQuarksSecret(copyNamespace, *quarksCopySecret)
			Expect(err).NotTo(HaveOccurred())

			By("Creating quarkssecret with copies")
			createQuarksSecretWithCopies(copyNamespace)
		})

		It("should copy the generated secret to the copy namespace if qsec is found", func() {
			By("Checking the quarkssecret status")
			checkStatus()
			checkCopyStatus()

			By("Checking the secret in source namespace")
			secret, err := env.GetSecret(env.Namespace, sourceSecret)
			Expect(err).NotTo(HaveOccurred())
			Expect(secret.Labels).To(Equal(map[string]string{
				"quarks.cloudfoundry.org/secret-kind": "generated",
			}))
			sourceSecretData := secret.StringData["password"]
			Expect(sourceSecretData).NotTo(BeNil())

			By("Checking the secret in target namespace")
			secret, err = env.GetSecret(copyNamespace, targetSecret)
			Expect(err).NotTo(HaveOccurred())
			Expect(secret.Labels).To(Equal(map[string]string{
				"quarks.cloudfoundry.org/secret-kind": "generated",
			}))
			targetSecretData := secret.StringData["password"]
			Expect(targetSecretData).NotTo(BeNil())
			Expect(targetSecretData).To(Equal(sourceSecretData))
		})

		It("should copy the rotated generated secret to the copy namespace if qsec is found", func() {
			By("Checking the quarkssecret status")
			checkStatus()
			checkCopyStatus()

			secret, err := env.CollectSecret(env.Namespace, sourceSecret)
			Expect(err).NotTo(HaveOccurred())
			Expect(secret.Labels).To(Equal(map[string]string{
				"quarks.cloudfoundry.org/secret-kind": "generated",
			}))

			By("Rotating the quarkssecret")
			rotationConfig := env.RotationConfig(qsecName)
			tearDown, err := env.CreateConfigMap(env.Namespace, rotationConfig)
			Expect(err).NotTo(HaveOccurred())
			tearDowns = append(tearDowns, tearDown)

			err = env.WaitForConfigMap(env.Namespace, "rotation-config1")
			Expect(err).NotTo(HaveOccurred())
			err = env.WaitForSecretChange(env.Namespace, sourceSecret, func(s corev1.Secret) bool {
				return !bytes.Equal(secret.Data["password"], s.Data["password"])
			})
			Expect(err).NotTo(HaveOccurred())

			By("Checking the quarkssecret status")
			checkCopyStatus()

			By("Checking the copied secret data")
			secret, err = env.CollectSecret(copyNamespace, targetSecret)
			Expect(err).NotTo(HaveOccurred())
			Expect(secret.Labels).To(Equal(map[string]string{
				"quarks.cloudfoundry.org/secret-kind": "generated",
			}))
			Expect(secret.StringData["password"]).NotTo(BeNil())
		})

		It("should copy the updated generated secret to the copy namespace when qsec is found", func() {
			By("Checking the quarkssecret status")
			checkStatus()
			checkCopyStatus()

			secret, err := env.CollectSecret(env.Namespace, sourceSecret)
			Expect(err).NotTo(HaveOccurred())
			Expect(secret.Labels).To(Equal(map[string]string{
				"quarks.cloudfoundry.org/secret-kind": "generated",
			}))
			oldSecretData := secret.Data["password"]

			By("Add labels to `SecretLabels` spec of quarkssecret")
			qs, err := env.GetQuarksSecret(env.Namespace, qsecName)
			Expect(err).NotTo(HaveOccurred())
			qs.Spec.SecretLabels = map[string]string{
				"LabelKeyv2": "LabelValuev2",
			}
			qs, err = env.UpdateQuarksSecret(env.Namespace, qs)
			Expect(err).NotTo(HaveOccurred())
			Expect(qs).NotTo(Equal(nil))

			Eventually(func() bool {
				secret, err = env.CollectSecret(env.Namespace, qs.Spec.SecretName)
				Expect(err).NotTo(HaveOccurred())
				return reflect.DeepEqual(secret.Labels, map[string]string{
					"LabelKeyv2":                          "LabelValuev2",
					"quarks.cloudfoundry.org/secret-kind": "generated",
				})
			}, 10*time.Second).Should(Equal(true))
			secret, err = env.CollectSecret(env.Namespace, qs.Spec.SecretName)
			Expect(err).NotTo(HaveOccurred())
			Expect(secret.Data["password"]).To(MatchRegexp("^\\w{64}$"))
			Expect(oldSecretData).To(Equal(secret.Data["password"]))

			By("Checking the quarkssecret status")
			checkCopyStatus()

			By("Check for the updated copy secret")
			Eventually(func() bool {
				secret, err = env.CollectSecret(qs.Spec.Copies[0].Namespace, qs.Spec.Copies[0].Name)
				Expect(err).NotTo(HaveOccurred())
				return reflect.DeepEqual(secret.Labels, map[string]string{
					"LabelKeyv2":                          "LabelValuev2",
					"quarks.cloudfoundry.org/secret-kind": "generated",
				})
			}, 10*time.Second).Should(Equal(true))

			secret, err = env.CollectSecret(qs.Spec.Copies[0].Namespace, qs.Spec.Copies[0].Name)
			Expect(err).NotTo(HaveOccurred())
			Expect(oldSecretData).To(Equal(secret.Data["password"]))
		})
	})

	Context("the secret is generated by operator for qsec copies", func() {
		BeforeEach(func() {
			passwordCopySecret := &corev1.Secret{
				ObjectMeta: metav1.ObjectMeta{
					Name:      targetSecret,
					Namespace: copyNamespace,
					Labels: map[string]string{
						"quarks.cloudfoundry.org/secret-kind": "generated",
					},
					Annotations: map[string]string{
						"quarks.cloudfoundry.org/secret-copy-of": env.Namespace + "/" + qsecName,
					},
				},
			}

			By("Creating copy empty password secret in copy namespace")
			tearDown, err := env.CreateSecret(copyNamespace, *passwordCopySecret)
			Expect(err).NotTo(HaveOccurred())
			tearDowns = append(tearDowns, tearDown)

			By("Creating quarkssecret with copies")
			createQuarksSecretWithCopies(copyNamespace)
		})

		It("should copy into other namespaces if copy secret if found", func() {
			By("Checking the quarkssecret status")
			checkStatus()

			By("Checking the secret in source namespace")
			secret, err := env.GetSecret(env.Namespace, sourceSecret)
			Expect(err).NotTo(HaveOccurred())
			Expect(secret.Labels).To(Equal(map[string]string{
				"quarks.cloudfoundry.org/secret-kind": "generated",
			}))
			sourceSecretData := secret.StringData["password"]
			Expect(sourceSecretData).NotTo(BeNil())

			By("Checking the secret in target namespace")
			secret, err = env.GetSecret(copyNamespace, targetSecret)
			Expect(err).NotTo(HaveOccurred())
			Expect(secret.Labels).To(Equal(map[string]string{
				"quarks.cloudfoundry.org/secret-kind": "generated",
			}))
			targetSecretData := secret.StringData["password"]
			Expect(targetSecretData).NotTo(BeNil())
			Expect(targetSecretData).To(Equal(sourceSecretData))
		})

		It("should copy the rotated generated secret to the copy namespace if copy secret is found", func() {
			By("Checking the quarkssecret status")
			checkStatus()
			checkCopyStatus()

			secret, err := env.CollectSecret(env.Namespace, sourceSecret)
			Expect(err).NotTo(HaveOccurred())
			Expect(secret.Labels).To(Equal(map[string]string{
				"quarks.cloudfoundry.org/secret-kind": "generated",
			}))

			By("Rotating the quarkssecret")
			rotationConfig := env.RotationConfig(qsecName)
			tearDown, err := env.CreateConfigMap(env.Namespace, rotationConfig)
			Expect(err).NotTo(HaveOccurred())
			tearDowns = append(tearDowns, tearDown)

			err = env.WaitForConfigMap(env.Namespace, "rotation-config1")
			Expect(err).NotTo(HaveOccurred())
			err = env.WaitForSecretChange(env.Namespace, sourceSecret, func(s corev1.Secret) bool {
				return !bytes.Equal(secret.Data["password"], s.Data["password"])
			})
			Expect(err).NotTo(HaveOccurred())

			By("Checking the quarkssecret status")
			checkStatus()
			checkCopyStatus()

			By("Checking the copied secret data")
			secret, err = env.CollectSecret(copyNamespace, targetSecret)
			Expect(err).NotTo(HaveOccurred())
			Expect(secret.Labels).To(Equal(map[string]string{
				"quarks.cloudfoundry.org/secret-kind": "generated",
			}))
			Expect(secret.StringData["password"]).NotTo(BeNil())
		})
	})

	Context("the user provides the password secret", func() {
		BeforeEach(func() {
			passwordSecret := &corev1.Secret{
				ObjectMeta: metav1.ObjectMeta{
					Name:      sourceSecret,
					Namespace: env.Namespace,
				},
				StringData: map[string]string{
					"password": "securepassword",
				},
			}

			By("Creating user password secret")
			tearDown, err := env.CreateSecret(env.Namespace, *passwordSecret)
			Expect(err).NotTo(HaveOccurred())
			tearDowns = append(tearDowns, tearDown)

			By("Creating quarkssecret")
			qsec = env.DefaultQuarksSecret(qsecName)
			_, tearDown, err = env.CreateQuarksSecret(env.Namespace, qsec)
			Expect(err).NotTo(HaveOccurred())
			tearDowns = append(tearDowns, tearDown)
		})

		It("should not generate the password secret", func() {
			By("Checking the quarkssecret status")
			Eventually(func() bool {
				qsec, err := env.GetQuarksSecret(env.Namespace, qsecName)
				Expect(err).NotTo(HaveOccurred())
				if qsec.Status.Generated != nil {
					return *qsec.Status.Generated
				}
				return false
			}).Should(Equal(true))

			By("Checking if it is the user created secret")
			secret, err := env.CollectSecret(env.Namespace, sourceSecret)
			Expect(err).NotTo(HaveOccurred())
			Expect(len(secret.Labels)).To(BeZero())
			Expect(string(secret.Data["password"])).To(Equal("securepassword"))
		})
	})

	Context("the user wants copies of the user password secret", func() {
		var passwordSecret *corev1.Secret

		BeforeEach(func() {
			passwordSecret = &corev1.Secret{
				ObjectMeta: metav1.ObjectMeta{
					Name:      sourceSecret,
					Namespace: env.Namespace,
				},
				StringData: map[string]string{
					"password": "securepassword",
				},
			}

			passwordCopySecret := &corev1.Secret{
				ObjectMeta: metav1.ObjectMeta{
					Name:      targetSecret,
					Namespace: copyNamespace,
					Annotations: map[string]string{
						"quarks.cloudfoundry.org/secret-copy-of": env.Namespace + "/" + qsecName,
					},
				},
			}

			By("Creating user password secret")
			tearDown, err := env.CreateSecret(env.Namespace, *passwordSecret)
			Expect(err).NotTo(HaveOccurred())
			tearDowns = append(tearDowns, tearDown)

			By("Creating copy empty password secret in copy namespace")
			tearDown, err = env.CreateSecret(copyNamespace, *passwordCopySecret)
			Expect(err).NotTo(HaveOccurred())
			tearDowns = append(tearDowns, tearDown)

			By("Creating quarkssecret with copies")
			createQuarksSecretWithCopies(copyNamespace)
		})

		It("should copy into other namespaces if copy empty secret if found", func() {
			By("Checking the quarkssecret status")
			checkStatus()
			checkCopyStatus()

			By("Checking the copied secret data")
			secret, err := env.CollectSecret(copyNamespace, targetSecret)
			Expect(err).NotTo(HaveOccurred())
			Expect(len(secret.Annotations)).To(Equal(1))
			Expect(string(secret.Data["password"])).To(Equal("securepassword"))
		})

		It("should update the copies in other namespaces if copy empty secret is found", func() {
			By("Checking the quarkssecret status")
			checkStatus()
			checkCopyStatus()

			By("Checking the copied secret data")
			secret, err := env.CollectSecret(copyNamespace, targetSecret)
			Expect(err).NotTo(HaveOccurred())
			Expect(len(secret.Annotations)).To(Equal(1))
			Expect(string(secret.Data["password"])).To(Equal("securepassword"))

			By("Updating the user password secret")
			passwordSecret.StringData["password"] = "supersecurepassword"
			_, tearDown, err := env.UpdateSecret(env.Namespace, *passwordSecret)
			Expect(err).NotTo(HaveOccurred())
			tearDowns = append(tearDowns, tearDown)

			By("Checking the quarkssecret status")
			checkCopyStatus()
			checkCopyStatus()

			By("Checking the copied secret data")
			secret, err = env.CollectSecret(copyNamespace, targetSecret)
			Expect(err).NotTo(HaveOccurred())
			Expect(len(secret.Annotations)).To(Equal(1))
			Expect(string(secret.Data["password"])).To(Equal("supersecurepassword"))
		})
	})

	Context("qsec wants copies of the user password secret", func() {
		var passwordSecret *corev1.Secret

		BeforeEach(func() {
			passwordSecret = &corev1.Secret{
				ObjectMeta: metav1.ObjectMeta{
					Name:      sourceSecret,
					Namespace: env.Namespace,
				},
				StringData: map[string]string{
					"password": "securepassword",
				},
			}

			quarksCopySecret := &qsv1a1.QuarksSecret{
				ObjectMeta: metav1.ObjectMeta{
					Name:      qsecName,
					Namespace: copyNamespace,
					Labels: map[string]string{
						"quarks.cloudfoundry.org/secret-kind": "generated",
					},
					Annotations: map[string]string{
						"quarks.cloudfoundry.org/secret-copy-of": env.Namespace + "/" + qsecName,
					},
				},
				Spec: qsv1a1.QuarksSecretSpec{
					Type:       "copy",
					SecretName: targetSecret,
				},
			}

			By("Creating user password secret")
			tearDown, err := env.CreateSecret(env.Namespace, *passwordSecret)
			Expect(err).NotTo(HaveOccurred())
			tearDowns = append(tearDowns, tearDown)

			By("Creating copy quarks secret in copy namespace")
			_, tearDown, err = env.CreateQuarksSecret(copyNamespace, *quarksCopySecret)
			Expect(err).NotTo(HaveOccurred())
			tearDowns = append(tearDowns, tearDown)

			By("Creating quarkssecret with copies")
			createQuarksSecretWithCopies(copyNamespace)
		})

		It("should copy into other namespaces if copy quarks secret if found", func() {
			By("Checking the quarkssecret status")
			checkStatus()
			checkCopyStatus()

			By("Checking the copied secret data")
			secret, err := env.CollectSecret(copyNamespace, targetSecret)
			Expect(err).NotTo(HaveOccurred())
			Expect(secret.Labels).To(BeZero())
			Expect(string(secret.Data["password"])).To(Equal("securepassword"))
		})

		It("should update the copies in other namespaces if copy quarks secret if found", func() {
			By("Updating the user password secret")
			passwordSecret.StringData["password"] = "supersecurepassword"
			_, tearDown, err := env.UpdateSecret(env.Namespace, *passwordSecret)
			Expect(err).NotTo(HaveOccurred())
			tearDowns = append(tearDowns, tearDown)

			By("Checking the quarkssecret status")
			checkStatus()
			checkCopyStatus()

			By("Checking the copied secret data")
			secret, err := env.CollectSecret(copyNamespace, targetSecret)
			Expect(err).NotTo(HaveOccurred())
			Expect(len(secret.Labels)).To(BeZero())
			Expect(string(secret.Data["password"])).To(Equal("supersecurepassword"))
		})
	})
})
